$date
	Fri Mar 14 15:17:26 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module four_bit_reg_top $end
$scope module four_bit_reg $end
$var wire 1 ! clk $end
$var wire 4 " d [3:0] $end
$var wire 1 # enable $end
$var wire 4 $ q [3:0] $end
$var wire 1 % reset $end
$var wire 1 & s8 $end
$var wire 1 ' s7 $end
$var wire 1 ( s6 $end
$var wire 1 ) s5 $end
$var wire 1 * s4 $end
$var wire 1 + s3 $end
$var wire 1 , s2 $end
$var wire 1 - s1 $end
$var wire 4 . s0 [3:0] $end
$var wire 4 / q_temp [3:0] $end
$scope module DIG_D_FF_AS_1bit_i1 $end
$var wire 1 ! C $end
$var wire 1 % Clr $end
$var wire 1 - D $end
$var wire 1 ) Q $end
$var wire 1 0 Set $end
$var wire 1 1 \~Q $end
$var parameter 32 2 Default $end
$var reg 1 3 state $end
$upscope $end
$scope module DIG_D_FF_AS_1bit_i2 $end
$var wire 1 ! C $end
$var wire 1 % Clr $end
$var wire 1 , D $end
$var wire 1 ( Q $end
$var wire 1 4 Set $end
$var wire 1 5 \~Q $end
$var parameter 32 6 Default $end
$var reg 1 7 state $end
$upscope $end
$scope module DIG_D_FF_AS_1bit_i3 $end
$var wire 1 ! C $end
$var wire 1 % Clr $end
$var wire 1 + D $end
$var wire 1 ' Q $end
$var wire 1 8 Set $end
$var wire 1 9 \~Q $end
$var parameter 32 : Default $end
$var reg 1 ; state $end
$upscope $end
$scope module DIG_D_FF_AS_1bit_i4 $end
$var wire 1 ! C $end
$var wire 1 % Clr $end
$var wire 1 * D $end
$var wire 1 & Q $end
$var wire 1 < Set $end
$var wire 1 = \~Q $end
$var parameter 32 > Default $end
$var reg 1 ? state $end
$upscope $end
$scope module four_bit_mux_i0 $end
$var wire 4 @ a [3:0] $end
$var wire 4 A b [3:0] $end
$var wire 1 # sel $end
$var wire 4 B y [3:0] $end
$var wire 1 C s9 $end
$var wire 1 D s8 $end
$var wire 1 E s7 $end
$var wire 1 F s6 $end
$var wire 1 G s5 $end
$var wire 1 H s4 $end
$var wire 1 I s3 $end
$var wire 1 J s2 $end
$var wire 1 K s11 $end
$var wire 1 L s10 $end
$var wire 1 M s1 $end
$var wire 1 N s0 $end
$scope module two_bit_mux_i0 $end
$var wire 1 N a $end
$var wire 1 M b $end
$var wire 1 # s $end
$var wire 1 J y $end
$upscope $end
$scope module two_bit_mux_i1 $end
$var wire 1 I a $end
$var wire 1 H b $end
$var wire 1 # s $end
$var wire 1 G y $end
$upscope $end
$scope module two_bit_mux_i2 $end
$var wire 1 F a $end
$var wire 1 E b $end
$var wire 1 # s $end
$var wire 1 D y $end
$upscope $end
$scope module two_bit_mux_i3 $end
$var wire 1 C a $end
$var wire 1 L b $end
$var wire 1 # s $end
$var wire 1 K y $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b0 >
b0 :
b0 6
b0 2
$end
#0
$dumpvars
0N
0M
0L
0K
0J
0I
0H
0G
0F
0E
0D
0C
b0 B
b0 A
b0 @
0?
1=
0<
0;
19
08
07
15
04
03
11
00
b0 /
b0 .
0-
0,
0+
0*
0)
0(
0'
0&
1%
b0 $
0#
b0 "
0!
$end
#5
1!
#10
1E
1L
b11 "
b11 A
0%
0!
#15
1!
#20
1+
1*
1D
b11 .
b11 B
1K
1#
0!
#25
09
1F
0=
1C
1'
1;
b11 $
b11 /
b11 @
1&
1?
1!
#30
1+
1*
1D
b11 .
b11 B
1K
1M
0L
b1010 "
b1010 A
0#
0!
#35
1!
#40
0*
1-
0K
b1010 .
b1010 B
1J
1#
0!
#45
01
1N
1=
0C
1)
13
b1010 $
b1010 /
b1010 @
0&
0?
1!
#50
11
0N
19
0F
0)
03
b0 $
b0 /
b0 @
0'
0;
0-
0+
0J
b0 .
b0 B
0D
0M
0E
b0 "
b0 A
0#
1%
0!
#55
1!
#60
1M
1H
1E
1L
b1111 "
b1111 A
0%
0!
#65
1!
#70
1-
1,
1+
1*
1J
1G
1D
b1111 .
b1111 B
1K
1#
0!
#75
01
1N
05
1I
09
1F
0=
1C
1)
13
1(
17
1'
1;
b1111 $
b1111 /
b1111 @
1&
1?
1!
#80
11
0N
15
0I
19
0F
1=
0C
0)
03
0(
07
0'
0;
b0 $
b0 /
b0 @
0&
0?
0-
0,
0+
0*
0J
0G
0D
b0 .
b0 B
0K
0M
0H
0E
0L
b0 "
b0 A
0#
1%
0!
